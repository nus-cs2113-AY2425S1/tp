package seedu.command;

import seedu.exceptions.InvalidDateFormatException;
import seedu.exceptions.InvalidDatePeriodException;
import seedu.message.CommandResultMessages;
import seedu.message.ErrorMessages;
import seedu.transaction.Transaction;
import seedu.transaction.TransactionList;
import seedu.utils.DateTimeUtils;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;


public class HistoryCommand extends Command{
    public static final String COMMAND_WORD = "history"; // The word associated with the command
    public static final String COMMAND_GUIDE = "history [f/ START_DATE] [t/ END_DATE]: "
            + "View your transaction history"; // A guide or description of the command
    public static final String[] COMMAND_MANDATORY_KEYWORDS = {}; // Keywords for arguments
    public static final String[] COMMAND_EXTRA_KEYWORDS = {"f/", "t/"}; // Keywords for arguments

    private TransactionList transactionList = new TransactionList();

    /**
     * Constructor sets the transaction list for the command.
     *
     * @param transactionList the input transaction list
     */
    public HistoryCommand(TransactionList transactionList) {
        setTransactionList(transactionList);
    }

    /**
     * Sets the transaction list for the command.
     *
     * @param transactionList the input transaction list
     */
    public void setTransactionList(TransactionList transactionList) {
        this.transactionList = transactionList;
    }

    /**
     * Executes the command and returns a list of income information.
     *
     * @return A list of strings containing the messages generated by the command execution.
     */
    @Override
    public List<String> execute() {
        List<String> messages = new ArrayList<>();

        String startDate = arguments.get(COMMAND_EXTRA_KEYWORDS[0]);
        String endDate = arguments.get(COMMAND_EXTRA_KEYWORDS[1]);

        List<Transaction> temp;

        temp = transactionList.getTransactions();
        try {
            LocalDateTime start;
            LocalDateTime end;
            if (startDate != null) {

                start = DateTimeUtils.parseDateTime(startDate);
                temp = temp.stream()
                        .filter((t) -> t.getDate().isAfter(start) || t.getDate().isEqual(start))
                        .collect(Collectors.toList());

            } else {
                start = null;
            }
            if (endDate != null) {

                String[] datetimeParts = endDate.trim().split(" ", 2);

                // If only the date is provided, append time as "0000" (00:00 AM)
                if (datetimeParts.length == 1) {
                    endDate += " 2359";
                }

                end = DateTimeUtils.parseDateTime(endDate);
                temp = temp.stream()
                        .filter((t) -> t.getDate().isBefore(end) || t.getDate().isEqual(end))
                        .collect(Collectors.toList());

            } else {
                end = null;
            }

            if (start!=null && end!=null) {
                if (start.isAfter(end)) {
                    throw new InvalidDatePeriodException(ErrorMessages.MESSAGE_INVALID_START_END);
                }
            }
        } catch (InvalidDateFormatException | InvalidDatePeriodException e) {
            messages.add(CommandResultMessages.VIEW_TRANSACTION_FAIL + e.getMessage());
            return messages;
        } catch (Exception e) {
            messages.add(ErrorMessages.UNEXPECTED_ERROR_MESSAGE + e.getMessage());
            return messages;
        }

        if (temp.isEmpty()) {
            messages.add(CommandResultMessages.VIEW_TRANSACTION_EMPTY);
            return messages;
        }

        List<Transaction> originalList = transactionList.getTransactions();

        for (Transaction transaction : temp) {
            messages.add((originalList.indexOf(transaction)+1) + ". " + transaction.toString());
        }

        return messages;
    }


    /**
     * Gets the mandatory keywords for the command.
     *
     * @return An array of strings containing the mandatory keywords associated with this command.
     */
    @Override
    protected String[] getMandatoryKeywords() {
        return COMMAND_MANDATORY_KEYWORDS;
    }

    /**
     * Gets the extra keywords for the command.
     *
     * @return An array of strings containing the extra keywords associated with this command.
     */
    @Override
    protected String[] getExtraKeywords() {
        return COMMAND_EXTRA_KEYWORDS;
    }

    /**
     * Gets the word for the command.
     *
     * @return A string representing the command word.
     */
    @Override
    protected String getCommandWord() {
        return COMMAND_WORD;
    }

    /**
     * Gets the guide for the command.
     *
     * @return A string representing the command guide.
     */
    @Override
    protected String getCommandGuide() {
        return COMMAND_GUIDE;
    }
}
